{
  "hash": "e5683043ff842cfa647b786727801068",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"MTG LLM Similar Card Search\"\nformat: html\ndate: \"2025-04-26\"\n---\n\n\nThis is my first time using LLM embeddings for a program. The goal is to get magic cards similar to a card I'm searching for, which I do quite often.\n\nMagic cards are quite similar. For example:\n\n::: {layout-ncol=3}\n![Llanowar Elves](https://cards.scryfall.io/large/front/6/a/6a0b230b-d391-4998-a3f7-7b158a0ec2cd.jpg?1731652605)\n\n![Elvish Mystic](https://cards.scryfall.io/large/front/7/5/75918859-c93f-41b4-9ad0-a4a96c389f0d.jpg?1689998466)\n\n![Fyndhorn Elder](https://cards.scryfall.io/large/front/8/1/81c125cd-ea49-4511-a78c-42c1f7ce802d.jpg?1562921174)\n:::\n\nI'd like to use an embedding to \n\n1. Search for a card by name\n2. Find cards similar to that\n\nI used an off-the-shelf model (`all-MiniLM-L6-v2`), downloaded card data from scryfall, then encoded cards like so:\n\n```\n# format\nname|type_line|mana_cost|oracle_text\n\n# example\n'Searslicer Goblin'|'Creature — Goblin Warrior'|'{1}{R}'|'Raid — At the beginning of your end step, if you attacked this turn, create a 1/1 red Goblin creature token.'\n```\n\n> I used Chat-GPT to scaffold the data processing and encoding scripts.  \n\nIn other words, the model will turn that string into a vector. Ideally, similar strings (i.e. cards) will be near eachother.\n\nHere I set everything up. I wanted to try using duckdb to query the embeddings.\n\n::: {#f0f2212b .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport duckdb\nimport numpy as np\nimport json\nfrom pathlib import Path\nfrom sentence_transformers import SentenceTransformer\n\n# Load files\ndata_dir = Path('../../.data')\nembeddings = np.load(data_dir/\"embeddings.npy\")\nwith open(data_dir/\"id_map.json\") as f:\n    id_map = json.load(f)\n\n# load model\nmodel = SentenceTransformer(\"all-MiniLM-L6-v2\")\n\n# data prep\nemb_dim = embeddings.shape[1]\ncard_embedding = (\n    pd.DataFrame([\n        {\"id\": card[\"id\"], \"embedding\": vec.tolist()}\n        for card, vec in zip(id_map, embeddings)\n    ])\n)\nparquet_file=data_dir / 'oracle-cards-20250425090226.parquet'\n\n# database\ndb = duckdb.connect(\":memory:\")\ndb.execute(f\"\"\" \nINSTALL vss;\nLOAD vss;\n\ncreate table card_embedding as \n    select \n        id\n        , embedding::DOUBLE[{emb_dim}] as embedding \n    from card_embedding\n;\n\ncreate table card as select * from '{parquet_file}';\n\"\"\")\n\n# how many cards?\ndb.sql('select count(*) as num_cards from card inner join card_embedding using(id)')\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"6adb4adcb6774f198feb6ec58914c469\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n┌───────────┐\n│ num_cards │\n│   int64   │\n├───────────┤\n│     30189 │\n└───────────┘\n```\n:::\n:::\n\n\nFirst, I need the ability to find the card I'm looking for in the database. I'll use the embedding for that.\n\n> Forgive any sloppiness. I wanted to focus on results, not code.\n\n::: {#577b2985 .cell execution_count=2}\n``` {.python .cell-code}\ndef search_for_card(conn, model, search_term, limit=1):\n    # sentence to vector\n    search_vec = model.encode([search_term])[0]\n    emb_dim = len(search_vec)\n    search_vec_str = \"ARRAY[\" + \",\".join(f\"CAST({x} AS DOUBLE)\" for x in search_vec) + \"]\"\n\n    # find similar vector\n    return conn.sql(f\"\"\"\n    select \n        id             \n        , card.name\n        , array_distance(embedding, {search_vec_str}::DOUBLE[{emb_dim}]) AS dist\n    from card_embedding \n    left join card using(id)\n    order by dist\n    limit {limit}\n    \"\"\")\n\ndef fetch_top_search_id(conn, model, search_term):\n    return search_for_card(conn, model, search_term, limit=1).fetchone()[0]\n\nassert fetch_top_search_id(db, model, 'llanowar elves') == '6a0b230b-d391-4998-a3f7-7b158a0ec2cd'\n```\n:::\n\n\nNow I want to find similar cards given an id.\n\n::: {#19e840c0 .cell execution_count=3}\n``` {.python .cell-code}\ndef query_closest_cards_to_id(conn, id, limit=9):\n    ref_vec = (\n        conn.sql(f\"select embedding from card_embedding where id='{id}'\")\n        .fetchone()[0]\n    )\n    emb_dim = len(ref_vec)\n    ref_vec_str = \"ARRAY[\" + \",\".join(f\"CAST({x} AS DOUBLE)\" for x in ref_vec) + \"]\"\n\n    return conn.sql(f\"\"\"\n        SELECT \n            card.name\n            , card.mana_cost\n            , card.oracle_text\n            , array_distance(embedding, {ref_vec_str}::DOUBLE[{emb_dim}]) AS dist\n        FROM card_embedding\n        left join card using(id)\n        ORDER BY dist asc\n        LIMIT {limit}\n    \"\"\")\n\nquery_closest_cards_to_id(db, '6a0b230b-d391-4998-a3f7-7b158a0ec2cd')\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n┌───────────────────┬───────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬──────────────────────┐\n│       name        │ mana_cost │                                                    oracle_text                                                     │         dist         │\n│      varchar      │  varchar  │                                                      varchar                                                       │        double        │\n├───────────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────────────────────┤\n│ Llanowar Elves    │ {G}       │ {T}: Add {G}.                                                                                                      │ 4.58366263816961e-17 │\n│ Llanowar Tribe    │ {G}{G}{G} │ {T}: Add {G}{G}{G}.                                                                                                │   0.4155691829580547 │\n│ Fyndhorn Elves    │ {G}       │ {T}: Add {G}.                                                                                                      │    0.555573984277023 │\n│ Greenweaver Druid │ {2}{G}    │ {T}: Add {G}{G}.                                                                                                   │   0.6204260670261244 │\n│ Elvish Mystic     │ {G}       │ {T}: Add {G}.                                                                                                      │    0.624662550035501 │\n│ Wirewood Elf      │ {1}{G}    │ {T}: Add {G}.                                                                                                      │   0.6288179733631174 │\n│ Llanowar Mentor   │ {G}       │ {G}, {T}, Discard a card: Create a 1/1 green Elf Druid creature token named Llanowar Elves. It has \"{T}: Add {G}.\" │   0.6507426519955598 │\n│ Llanowar Dead     │ {B}{G}    │ {T}: Add {B}.                                                                                                      │   0.6539462847478972 │\n│ Urborg Elf        │ {1}{G}    │ {T}: Add {B}, {G}, or {U}.                                                                                         │   0.6550689705646989 │\n└───────────────────┴───────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────────┘\n```\n:::\n:::\n\n\nGluing it all together:\n\n::: {#b7c1bd04 .cell execution_count=4}\n``` {.python .cell-code}\ndef query_closest_cards_to_search(conn, model, search_term, limit=9):\n    id = fetch_top_search_id(conn, model, search_term)\n    return query_closest_cards_to_id(conn, id, limit=limit)\n\nquery_closest_cards_to_search(db, model, \"llanowar elves\")\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n┌───────────────────┬───────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬──────────────────────┐\n│       name        │ mana_cost │                                                    oracle_text                                                     │         dist         │\n│      varchar      │  varchar  │                                                      varchar                                                       │        double        │\n├───────────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────────────────────┤\n│ Llanowar Elves    │ {G}       │ {T}: Add {G}.                                                                                                      │ 4.58366263816961e-17 │\n│ Llanowar Tribe    │ {G}{G}{G} │ {T}: Add {G}{G}{G}.                                                                                                │   0.4155691829580547 │\n│ Fyndhorn Elves    │ {G}       │ {T}: Add {G}.                                                                                                      │    0.555573984277023 │\n│ Greenweaver Druid │ {2}{G}    │ {T}: Add {G}{G}.                                                                                                   │   0.6204260670261244 │\n│ Elvish Mystic     │ {G}       │ {T}: Add {G}.                                                                                                      │    0.624662550035501 │\n│ Wirewood Elf      │ {1}{G}    │ {T}: Add {G}.                                                                                                      │   0.6288179733631174 │\n│ Llanowar Mentor   │ {G}       │ {G}, {T}, Discard a card: Create a 1/1 green Elf Druid creature token named Llanowar Elves. It has \"{T}: Add {G}.\" │   0.6507426519955598 │\n│ Llanowar Dead     │ {B}{G}    │ {T}: Add {B}.                                                                                                      │   0.6539462847478972 │\n│ Urborg Elf        │ {1}{G}    │ {T}: Add {B}, {G}, or {U}.                                                                                         │   0.6550689705646989 │\n└───────────────────┴───────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────────┘\n```\n:::\n:::\n\n\n## Eyeball Evaluation\n\nThis ordering is not perfect. For example:\n\n- `Llanowar Tribe│ {G}{G}{G} │ {T}: Add {G}{G}{G}.` is the \"top\" result\n- `Fyndhorn Elves    │ {G}       │ {T}: Add {G}.` and other cards functionally identical to Llanowar Elves are rated lower.\n\nI think this happens because I encode the `name` of the card in the embedding, which I chose to make search easier. \n\n- Perhaps I should make two embeddings if my use-case is scoped this narrowly.\n- The tradeoff is that I would need another API to do generalized search e.g. \"{T}: Add {G}\"\n\n## Extending\n\nWe can make the query more flexible to account for different contexts. With this we combine the power of traditional querying with vector search.\n\n::: {#1132d936 .cell execution_count=5}\n``` {.python .cell-code}\ndef sql_array_distance_from_search(conn, model, search_term):\n    id = fetch_top_search_id(conn, model, search_term)\n    ref_vec = (\n        conn.sql(f\"select embedding from card_embedding where id='{id}'\")\n        .fetchone()[0]\n    )\n    emb_dim = len(ref_vec)\n    ref_vec_str = \"ARRAY[\" + \",\".join(f\"CAST({x} AS DOUBLE)\" for x in ref_vec) + \"]\"\n    return f\"array_distance(embedding, {ref_vec_str}::DOUBLE[{emb_dim}])\"\n\ndb.sql(f\"\"\" \nselect \n    name\n    , oracle_text\n    , {sql_array_distance_from_search(db, model, 'when you cycle')} as dist\nfrom card_embedding\nleft join card using(id)\nwhere 1=1\n    and layout = 'normal'\n    and cmc = 2\norder by dist asc\nlimit 9\n\"\"\")\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n┌────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬───────────────────────┐\n│          name          │                                                                   oracle_text                                                                   │         dist          │\n│        varchar         │                                                                     varchar                                                                     │        double         │\n├────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼───────────────────────┤\n│ Drannith Healer        │ Whenever you cycle another card, you gain 1 life.\\nCycling {1} ({1}, Discard this card: Draw a card.)                                           │ 4.804520544858501e-17 │\n│ Drannith Stinger       │ Whenever you cycle another card, this creature deals 1 damage to each opponent.\\nCycling {1} ({1}, Discard this card: Draw a card.)             │    0.7654649610995645 │\n│ Witherbloom Apprentice │ Magecraft — Whenever you cast or copy an instant or sorcery spell, each opponent loses 1 life and you gain 1 life.                              │    0.9166975304148206 │\n│ Blessed Wine           │ You gain 1 life.\\nDraw a card at the beginning of the next turn's upkeep.                                                                       │    0.9202103106272829 │\n│ Revitalize             │ You gain 3 life.\\nDraw a card.                                                                                                                  │    0.9227281467739591 │\n│ Disciple of Law        │ Protection from red\\nCycling {2} ({2}, Discard this card: Draw a card.)                                                                         │    0.9279500413320395 │\n│ Soul Shepherd          │ {W}, Exile a creature card from your graveyard: You gain 1 life.                                                                                │    0.9443892064122495 │\n│ Syndic of Tithes       │ Extort (Whenever you cast a spell, you may pay {W/B}. If you do, each opponent loses 1 life and you gain that much life.)                       │     0.950814787176584 │\n│ Samite Herbalist       │ Whenever this creature becomes tapped, you gain 1 life and scry 1. (Look at the top card of your library. You may put that card on the bottom.) │    0.9514616126869583 │\n└────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴───────────────────────┘\n```\n:::\n:::\n\n\n## What's next?\n\nI think I need better recommendations before I go any further. The results need to be \"good enough,\" but they're not quite there. I'll have to look into what it takes to refine the model for my use-case.\n\nMaking an app (probably a simple webapp) would be the most helpful interface. Even 5-10 recommendations would be helpful.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script src=\"https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js\" crossorigin=\"anonymous\"></script>\n"
      ],
      "include-after-body": [
        "<script type=application/vnd.jupyter.widget-state+json>\n{\"state\":{\"2ed50c91741343459faebd22b97ab024\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":\"auto\"}},\"6adb4adcb6774f198feb6ec58914c469\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"FloatProgressModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"FloatProgressModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"ProgressView\",\"bar_style\":\"\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_2ed50c91741343459faebd22b97ab024\",\"max\":100,\"min\":0,\"orientation\":\"horizontal\",\"style\":\"IPY_MODEL_e3e2b004289b44eb8dea372cf79a9c12\",\"tabbable\":null,\"tooltip\":null,\"value\":100}},\"e3e2b004289b44eb8dea372cf79a9c12\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"ProgressStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"ProgressStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"bar_color\":\"black\",\"description_width\":\"\"}}},\"version_major\":2,\"version_minor\":0}\n</script>\n"
      ]
    }
  }
}