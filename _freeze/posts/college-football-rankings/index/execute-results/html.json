{
  "hash": "83c9cae093f4c936e32f41155a5c1947",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"College Football Rankings\"\ndate: \"2025-02-20\"\n---\n\n\nThis is a quick-and-dirty implementation Fiddler on the Proof's [Reasonable Rankings for College Football](https://thefiddler.substack.com/p/reasonable-rankings-for-college-football). Their proposal uses the score-differentials between games. Once you have all the scores, you solve a linear equation to rank teams based on how the did against one-another, and even consider how they did amongst similar teams.\n\n## Data \n\nHere I gather the data for the 2024 season from https://www.sports-reference.com. \n\n::: {#f04dd662 .cell execution_count=1}\n``` {.python .cell-code}\nfrom  types import SimpleNamespace\n\nimport pandas as pd\nimport duckdb\nimport numpy as np\n\nimport requests\nfrom bs4 import BeautifulSoup\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotnine as pn\n\nurl = \"https://www.sports-reference.com/cfb/years/2024-schedule.html#schedule\"\n\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.content)\n\n# Find the table (inspect the webpage to find the correct table tag and attributes)\ntable = soup.find(\"table\", id=\"schedule\")\n\n# use these table headers\nheaders = [\n    \"week\",\n    \"date\",\n    \"time\",\n    \"day\",\n    \"winner\",\n    \"winner_points\",\n    \"home\",\n    \"loser\",\n    \"loser_points\",\n    \"notes\"\n]\n\n# Extract table rows\nrows = []\nfor tr in table.find(\"tbody\").find_all(\"tr\"):\n    row = []\n    for td in tr.find_all(\"td\"):\n        row.append(td.text)\n    rows.append(row)\n\n# Create pandas DataFrame\nscores_raw = (\n    pd.DataFrame(rows, columns=headers)\n    .dropna(subset=[\"week\"])\n)\nscores_raw.iloc[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nweek                              1\ndate                   Aug 24, 2024\ntime                       12:00 PM\nday                             Sat\nwinner                 Georgia Tech\nwinner_points                    24\nhome                              N\nloser            (10) Florida State\nloser_points                     21\nnotes                              \nName: 0, dtype: object\n```\n:::\n:::\n\n\nHere I clean up the scores table.\n\n::: {#de716f8c .cell execution_count=2}\n``` {.python .cell-code}\nscores = duckdb.query(\"\"\"\nwith scores as (\n  select\n    row_number() over() as game_id\n    , trim(regexp_replace(winner, '(\\(\\d+\\))', '')) as winner\n    , trim(regexp_replace(loser, '(\\(\\d+\\))', '')) as loser\n    , cast(coalesce(nullif(winner_points, ''), '0') as int) as winner_points\n    , cast(coalesce(nullif(loser_points, ''), '0') as int) as loser_points\n  from scores_raw\n  where 1=1 and week is not null\n)\nselect\n  *\n  , loser_points\n  , winner_points - loser_points as diff_points\nfrom scores\nwhere 1=1 \n    and winner_points + loser_points > 0\n\"\"\")\n\nduckdb.query(\"select * from scores limit 4\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:1: SyntaxWarning: invalid escape sequence '\\('\n<>:1: SyntaxWarning: invalid escape sequence '\\('\n/var/folders/bm/vmrvtfpd56v9sw0pb7c_rp0w0000gp/T/ipykernel_37883/3745766914.py:1: SyntaxWarning: invalid escape sequence '\\('\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n┌─────────┬────────────────────┬────────────────┬───────────────┬──────────────┬────────────────┬─────────────┐\n│ game_id │       winner       │     loser      │ winner_points │ loser_points │ loser_points_1 │ diff_points │\n│  int64  │      varchar       │    varchar     │     int32     │    int32     │     int32      │    int32    │\n├─────────┼────────────────────┼────────────────┼───────────────┼──────────────┼────────────────┼─────────────┤\n│       1 │ Georgia Tech       │ Florida State  │            24 │           21 │             21 │           3 │\n│       2 │ Montana State      │ New Mexico     │            35 │           31 │             31 │           4 │\n│       3 │ Southern Methodist │ Nevada         │            29 │           24 │             24 │           5 │\n│       4 │ Hawaii             │ Delaware State │            35 │           14 │             14 │          21 │\n└─────────┴────────────────────┴────────────────┴───────────────┴──────────────┴────────────────┴─────────────┘\n```\n:::\n:::\n\n\nConstruct the \"game matrix,\" which is made up of `-1,0,1`.\n\n- Each row represents a game\n- Each column represents a team\n- An entry is 1 if the team won that game, -1 if it lost that game, 0 otherwise\n\nEach game will have a corresponding score, which we keep in another vector. \n\n::: {#e4942122 .cell execution_count=3}\n``` {.python .cell-code}\nteams = duckdb.query(\"\"\"\nwith teams as (\n  select distinct winner as team\n  from scores\n  union all\n  select distinct loser as team\n  from scores\n)\nselect team\nfrom teams\norder by team\n\"\"\")\n\nteam_mapping = {team: i for i, team in enumerate(teams.to_df()['team']) }\n\ngame_matrix = np.zeros((scores.shape[0], teams.shape[0]))\nfor i, row in scores.to_df().iterrows():\n  game_matrix[i, team_mapping[row['winner']]] = 1\n  game_matrix[i, team_mapping[row['loser']]] = -1\n\n\"{} games, {} teams\".format(*game_matrix.shape)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'919 games, 367 teams'\n```\n:::\n:::\n\n\n## What's a game worth?\n\nThe Fiddler maps a score-differential to a weight between 0 and 1. They recommend the function below. It accepts the number of points the winners won by (i.e. a positive number) and returns a weight between 0 and 1 (1 is better than 0).\n\n::: {#47256457 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\ndef weigh(points_won_by, alpha:float=1.0):\n  return (2 / (1+np.exp(-points_won_by / alpha))) - 1\n```\n:::\n\n\nThere has a tunable parameter, `alpha`, which means we can decide how to weigh different wins, e.g.\n- when `alpha=0`, \"a win is a win,\" so a team that wins by 1 point is just as good as a team that wins by 14 points\n- when `alpha=5`, a team that wins by 1 point doesn't get a strong weight (closer to 0), while a team that wins by 14 points gets a weight of ~0.8.\n\nAs `alpha` increases, teams need larger point differentials to do well. \n\n::: {#2ac71004 .cell execution_count=5}\n``` {.python .cell-code}\n(\n  pd.concat([(\n      pd.DataFrame({\"Won By\": np.arange(0, 19)})\n      .assign(alpha=a)\n      .assign(Weight=lambda df: weigh(df[\"Won By\"], alpha=a))\n    ) for a in [0, 1, 2, 5]\n  ], ignore_index=True)\n  .pipe(pn.ggplot)\n    + pn.geom_line(pn.aes(x=\"Won By\", y=\"Weight\", color=\"factor(alpha)\"))\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/plotnine/geoms/geom_path.py:100: PlotnineWarning: geom_path: Removed 1 rows containing missing values.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-2.png){width=672 height=480}\n:::\n:::\n\n\nSo what `alpha` should we choose? I would work backwards from a score, e.g. \"a 14-point (2 touchdowns) win is a decisive win.\" \n\nBelow I've plotted the distribution of points the winner won by. We see that 14 points is the median, so my reasoning feels decent.\n\n::: {#de68303b .cell execution_count=6}\n``` {.python .cell-code}\n(\n  # point diff ecdf\n  scores.to_df()\n  .pipe(lambda df: (\n    pn.ggplot(scores.to_df())\n    + pn.stat_ecdf(pn.aes(\"diff_points\"))\n    # plot median\n    + pn.geom_label(x=df.diff_points.median(),y=0.5,label=df.diff_points.median())\n    + pn.labs(title=\"Point Differential ECDF\")\n  ))\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-1.png){width=672 height=480}\n:::\n:::\n\n\nUsing our eyeballs to compare the two plots above, `alpha=2` is a reasonable parameter, since it counts 14-point games as a \"decisive\" victory. \n\n## Ranking the Teams\n\nWith this we can set up a linear equation:\n\n```\ngames_matrix * team_weights = game_weights\n^known^^^^^^   ^unknown^^^^   ^known^^^^^^        \n```\n\nAt this point I like to test my assumptions about the shapes and content of my data:\n\n::: {#bb106fef .cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nnum_games = scores.shape[0]\nnum_teams = teams.shape[0]\n\nassert game_matrix.shape == (num_games, num_teams)\nassert (game_matrix==1).sum() == num_games # winners get a 1\nassert (game_matrix==-1).sum() == num_games # losers get a -1\n\nexample_game_weights = weigh(scores.to_df().diff_points, 2)\nassert example_game_weights.shape == (num_games,)\nassert ((example_game_weights>=0) & (example_game_weights<=1)).sum() == num_games # values between 0 and 1\n\n\"No errors!\"\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'No errors!'\n```\n:::\n:::\n\n\nNow we can solve this equation. Once we have `team_weights`, we can pull the top 12 to get our finalists.\n\n::: {#5c6451ad .cell execution_count=8}\n``` {.python .cell-code}\ndef solve_for_team_weights(games_, teams_, diff_points_, alpha=2):\n  weights = weigh(diff_points_, alpha=alpha)\n  pseudoinverse = np.linalg.pinv(games_)\n  rankings = pseudoinverse @ np.array(weights)\n\n  return pd.Series({\n      team: rankings[i]\n      for i, team in enumerate(teams_.to_df()['team'])\n  })\n\nrankings = solve_for_team_weights(\n  game_matrix, \n  teams,\n  scores.to_df().diff_points\n)\n\n# get top 12\nrankings.sort_values(ascending=False).head(12)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nOhio State        1.665191\nOregon            1.548168\nNotre Dame        1.468274\nPenn State        1.333366\nTexas             1.324272\nIndiana           1.217931\nGeorgia           1.100962\nIllinois          1.087538\nSouth Carolina    1.084789\nMississippi       1.081674\nBrigham Young     1.078441\nMichigan          1.046878\ndtype: float64\n```\n:::\n:::\n\n\n## Sensitivity\n\nI'm curious how changing `alpha` changes the top-12 composition. Recall that increasing `alpha` means we weigh bigger score differentials more heavily. \n\nAs we increase alpha, we see that:\n\n- Ohio State is always #1\n- Alabama makes it for alpha>2\n- The higher (i.e. worse) seeds are slightly more competitive\n- Miami gets in at `alpha~=12`\n\n::: {#a3682967 .cell execution_count=9}\n``` {.python .cell-code}\nsens = SimpleNamespace()\nsens.data = []\nsens.fig, sens.ax = plt.subplots()\n\nfor a in np.linspace(0, 20, 11):\n  sens.tw = (\n    solve_for_team_weights(\n      game_matrix,\n      teams,\n      scores.to_df().diff_points,\n      alpha=a\n    )\n    .sort_values(ascending=False)\n    .head(12)\n    # I don't like pandas\n    .reset_index().rename(columns={\"index\": \"team\", 0: \"team_score\"})\n    .assign(alpha=np.round(a), seed=lambda df: df.index+1)\n  )\n  sens.data.append(sens.tw)\n\n(\n  pd.concat(sens.data, ignore_index=True)\n  .pivot(index=\"team\", columns=\"alpha\", values=\"seed\")\n  # sort by avg rank\n  .pipe(lambda df: df.loc[df.max(axis=1).sort_values().index])\n  .pipe(lambda df: sns.heatmap(df, annot=True, ax=sens.ax))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<Axes: xlabel='alpha', ylabel='team'>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}