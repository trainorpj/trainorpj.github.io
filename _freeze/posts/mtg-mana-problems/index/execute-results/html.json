{
  "hash": "7352515668d6682707ae28828214351f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Simulating Magic's Mana Problems\"\nformat: html\ndate: \"2025-04-20\"\n---\n\n\nThis post puts numbers to common \"mana problems\" in Magic: The Gathering. If you don't play Magic, this is about using simulation instead of traditional probability distributions (i.e. the oft-misunderstood [hypergeometric distribution](https://en.wikipedia.org/wiki/Hypergeometric_distribution)).\n\nIn Magic, there are generally two types of cards:\n\n- **Spells** are the main game pieces. You need them to win the game.\n- **Lands** are the resource that lets you cast spells. You need a healthy supply of lands to play spells, and therefore win the game.\n\nA deck of cards typically has 23 spells and 17 lands. You start with 7 cards, and draw a card each turn. If you have 7 spells in-hand (and therefore 0 lands), you can't actually cast them until you draw lands.\n\nHere's an example starting hand from a shuffled deck. \n\n::: {#d60b29dd .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport duckdb\nimport numpy as np\nfrom scipy import stats\nimport plotnine as pn\n\ndef make_deck():\n    deck = [\"Land\" for _ in range(17)]\n    deck.extend([\"Spell\" for _ in range(23)])\n    np.random.shuffle(deck)\n    return deck\n\ndef get_counts(cards):\n    return pd.Series(cards).value_counts()\n\n# example first hand\nget_counts(make_deck()[:7])\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nSpell    4\nLand     3\nName: count, dtype: int64\n```\n:::\n:::\n\n\nHow many lands should we expect to have in our opening hand? Probability textbooks would suggest the hypergeometric distribution, but I suggest using simulation instead.\n\nThe plot below shows that ~50% of the time we have 3 or 4 lands, which is a healthy ideal number.\n\nI've also included the actual hypergeometric distribution values to check my work. They match up, but I think the simulation is much easier to follow.\n\n::: {#06f11033 .cell execution_count=2}\n``` {.python .cell-code}\nnum_sim = 601\nopening_hands = (\n    pd.DataFrame({\n        # shuffle the deck, draw 7 cards from the top, count the lands\n        i: get_counts(make_deck()[:7])\n        for i in range(num_sim)\n    })\n    .T\n    .fillna(0)\n)\n\n# the actual distribution\nhg = stats.hypergeom(40, 17, 7)\nhg_cdf = pd.DataFrame({\"Land\": np.arange(0, 7)})\nhg_cdf[\"cdf\"] = hg.cdf(hg_cdf.Land)\n\n# print results\nprint(duckdb.query(f\"\"\" \nselect \n    count(*) filter(Land between 3 and 4) / count(*) as sim_frac_3_4\n    , {hg.pmf(3) + hg.pmf(4)} as actual_frac_3_4\nfrom opening_hands \n\"\"\"))\n\n# plots cdfs\n(\n    pn.ggplot(data=opening_hands) +\n    pn.geom_col(hg_cdf, pn.aes(\"Land\", \"cdf\"), fill=\"white\") +\n    pn.stat_ecdf(pn.aes(\"Land\")) +\n    pn.labs(title=\"Opening Hand Num Lands CDF\", subtitle=\"Bars show stats.hypergeom(40, 17, 7) CDF\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌──────────────────┬────────────────────┐\n│   sim_frac_3_4   │  actual_frac_3_4   │\n│      double      │   decimal(17,16)   │\n├──────────────────┼────────────────────┤\n│ 0.56738768718802 │ 0.5490571543203121 │\n└──────────────────┴────────────────────┘\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-2.png){width=672 height=480}\n:::\n:::\n\n\nSuppose you decide to keep _any_ hand, e.g. one with 2 lands and 5 spells. You'll draw a card each turn, so how many lands should you expect to get?\n\nFirst we'll set up a function to simulate this. Here we get the cumulative counts of spells and lands after each draw.\n\n::: {#a3233774 .cell execution_count=3}\n``` {.python .cell-code}\ndef get_turn_counts(deck, num_start=7, num_draws=6):\n    counts = {\n        i: get_counts(deck[:(num_start+i)])\n        for i in range(num_draws+1)\n    }\n    return (\n        pd.DataFrame(counts).T\n        .reset_index(names=[\"draw\"])\n        .fillna(0)\n    )\n\n# example\nget_turn_counts(make_deck())\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>draw</th>\n      <th>Land</th>\n      <th>Spell</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>5</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>6</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>7</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3</td>\n      <td>8</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>4</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>5</td>\n      <td>9</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>6</td>\n      <td>9</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow we'll simulate many draws and tally the results. We see that:\n\n- Our turn 0 results hold; ~50% of the time you have 3-4 lands (good), ~35% of the time you have 2 or fewer Lands (bad).\n- By your 2nd draw, ~60% of the time you've drawn 3-5 lands, and there's a 15% chance you've only drawn 2 or fewer lands.\n\n::: {#090a227d .cell execution_count=4}\n``` {.python .cell-code}\ndraw_sims = (\n    pd.concat([\n        get_turn_counts(make_deck()).assign(sim_id=i)\n        for i in range(num_sim)\n    ], ignore_index=True)\n)\n\n(\n    duckdb.sql(\"\"\"\n    select \n        draw\n        , Land\n        , count(*) as num\n        , SUM(COUNT(*)) OVER (partition by draw) as num_draws\n        , num / num_draws AS draw_frac\n    from draw_sims\n    group by draw, Land\n    order by draw\n    \"\"\")\n    .to_df()\n    .pipe(pn.ggplot)\n    + pn.geom_tile(pn.aes(\"draw\", \"Land\", fill=\"draw_frac\"))\n    + pn.geom_text(pn.aes(\"draw\", \"Land\", label=\"round(draw_frac, 2)\"))\n    + pn.scale_fill_continuous(cmap_name=\"Blues\")\n    + pn.labs(y=\"total lands drawn\", x=\"draw\")\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=672 height=480}\n:::\n:::\n\n\nSuppose you have drawn an opening hand with only two lands (~10% chance). What should you expect to see in the coming draws? Here we'll draw out the cdf for each draw. \n\nWe see that by your 2nd draw, there's a good chance you have 3 or 4 lands.\n\n::: {#dcde1f66 .cell execution_count=5}\n``` {.python .cell-code}\nprint(duckdb.sql(\"\"\"select count(*) filter(Land=2) as \"Num Two-Land Openers\" from draw_sims\"\"\"))\n\n(\n    duckdb.sql(\"\"\" \n    select \n        draw\n        , Land\n        , count(*) as num\n        , SUM(COUNT(*)) OVER (partition by draw) as num_draws\n        , num / num_draws AS draw_frac\n    from (\n        select sim_id\n        from draw_sims\n        where draw=0 and Land=2\n    ) as two_land_openers \n    left join draw_sims using(sim_id)\n    where 1=1 \n        and draw > 0 -- first draw will always have Land=2\n    group by draw, Land\n    order by draw\n    \"\"\")\n    .to_df().pipe(pn.ggplot)\n    + pn.stat_ecdf(pn.aes(\"Land\"), geom=\"col\") \n    + pn.facet_wrap(\"draw\", labeller=\"label_both\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌──────────────────────┐\n│ Num Two-Land Openers │\n│        int64         │\n├──────────────────────┤\n│                  434 │\n└──────────────────────┘\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-3.png){width=672 height=480}\n:::\n:::\n\n\n## Mulligans\n\nYou have the option to \"mulligan\" your opening hand, i.e. you can shuffle, re-draw 7 cards, then put one on the bottom of your deck. \n\n> This is another benefit of simulation. I don't even want to bother finding the probability distribution for this. Even if I could figure it out, I wouldn't want to explain it to other people. People can understand code.\n\nHere's some janky mulligan logic. I wrote a check at the bottom to see how often we get different starting hand sizes. ~80% of the time we have 7 or 6 cards to start. \n\n::: {#6fe8f561 .cell execution_count=6}\n``` {.python .cell-code}\ndef mulligan_keep_check(hand) -> bool:\n    counts = get_counts(hand)\n    num_lands = 0 if \"Land\" not in counts.keys() else counts.Land\n    if 3 <= num_lands <= 4:\n        return True\n    return False\n\ndef mulligan_choice(hand, num_mulligan: int):\n    # Choose as many lands as you can ... not ideal, but I didn't feel\n    # like doing something more sophisticated\n    hand = sorted(hand)\n    new_hand, bottom = hand[:-num_mulligan], hand[-num_mulligan:]\n    return new_hand, bottom\n\nassert mulligan_choice(list(\"SLSSSLS\"), 2) == ([\"L\", \"L\", \"S\", \"S\", \"S\"], [\"S\", \"S\"])\n\ndef make_deck_with_mulligan(\n    num_start=7, \n    max_mulligans=2,\n    mulligan_keep_check_fcn=mulligan_keep_check,\n    mulligan_choice_fcn=mulligan_choice\n):\n    # setup\n    keep_hand = False\n    num_mulligans = -1\n\n    # mulligan until you reach your max, or until you decide to keep\n    while all([\n        num_mulligans < max_mulligans, \n        not keep_hand\n    ]):\n        # this only updates when keep is False\n        num_mulligans += 1\n        \n        # split up and and deck\n        deck = make_deck()\n        hand, rest_of_deck = deck[:num_start], deck[num_start:]\n\n        # update state\n        keep_hand = mulligan_keep_check_fcn(hand)\n    \n    if num_mulligans > 0:\n        new_hand, bottom = mulligan_choice(hand, num_mulligans)\n        num_start = len(new_hand)\n        deck = [*new_hand,*rest_of_deck,*bottom]\n\n    return deck, num_start\n\n# check opening hand sizes w/ mulligans\npd.Series([make_deck_with_mulligan()[1] for _ in range(201)]).value_counts(normalize=True).sort_index()\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n5    0.174129\n6    0.208955\n7    0.616915\nName: proportion, dtype: float64\n```\n:::\n:::\n\n\nThe table and plot below show how it changes our opening hands. We go from a 60% chance of having 3-4 lands to a 90% chance after we mulligan.\n\nThat's a pretty strong case for choosing a mulligan!\n\n::: {#1c085f25 .cell execution_count=7}\n``` {.python .cell-code}\n# [(deck, num_start)]\nmull_sim_decks = [make_deck_with_mulligan() for _ in range(num_sim)]\nmull_sim_draws = pd.concat([\n    get_turn_counts(deck, num_start=num_start).assign(sim_id=i, num_start=num_start)\n    for i, (deck, num_start) in enumerate(mull_sim_decks)\n], ignore_index=True)\n\ncomb_sims = duckdb.query(\"\"\"\nselect 'no-mull' as strategy, draw, land, 7 as num_start\nfrom draw_sims\nunion all by name\nselect 'mull' as strategy, draw, land, num_start\nfrom mull_sim_draws\n\"\"\")\n\nprint(duckdb.query(\"\"\" \nselect\n    strategy\n    , sum(land between 3 and 4) as num_3_4\n    , count(*) num_sims\n    , round(num_3_4 / num_sims, 2) as frac_3_4\nfrom comb_sims\nwhere 1=1 and draw = 0\ngroup by strategy\n\"\"\"))\n\n(\n    duckdb.query(\"\"\" \n    select\n        strategy\n        , land\n        , count(*) as num\n        , SUM(COUNT(*)) OVER (partition by strategy) as num_draws\n        , num / num_draws AS draw_frac\n    from comb_sims\n    where 1=1 and draw = 0\n    group by strategy, land\n    \"\"\")\n    .to_df().pipe(pn.ggplot)\n    + pn.stat_ecdf(pn.aes(x=\"Land\", fill=\"strategy\"), geom=\"col\", position=\"dodge\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌──────────┬─────────┬──────────┬──────────┐\n│ strategy │ num_3_4 │ num_sims │ frac_3_4 │\n│ varchar  │ int128  │  int64   │  double  │\n├──────────┼─────────┼──────────┼──────────┤\n│ no-mull  │     336 │      601 │     0.56 │\n│ mull     │     545 │      601 │     0.91 │\n└──────────┴─────────┴──────────┴──────────┘\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: invalid value encountered in reduce\n/Users/pj/Documents/trainorpj.github.io/.venv/lib/python3.13/site-packages/plotnine/layer.py:364: PlotnineWarning: geom_col : Removed 4 rows containing missing values.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-3.png){width=672 height=480}\n:::\n:::\n\n\n## Where to go next\n\nSome other directions to take this:\n\n1. The composition of your deck is hugely important to what spells you can play. If most of your spells only cost one mana (i.e. land), can you live with only one or two lands in your starting hand?\n2. Can we incorporate that into our mulligan decisions? I made the mulligan function flexible enough that you can try different strategies.\n3. What is the ideal number of lands? Conventional wisdom (I'm sure backed up by math) says 17 is the ideal number.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}